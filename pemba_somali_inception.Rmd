---
title: "Untitled"
author: "Masumbuko Semba"
date: "March 4, 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

One major task for scientists in his their daily routine is to prepare compelling graphics for technical document, reports or manuscripts for publication. Graphics in form of figures carry the weight of the arguments. They need to be clear, attractive and convincing. according to [@], the difference between good and bad figures always lead into the difference between a highly influential or an obscure paper; a grant/contract won or lost; and a job interview gone well or poorly.

For the last ten years I have squeezed myself into preparing figures for scientific publications and have made throusands of figures. Honestly to say that over this period I have switched from one software to the other in the figure preparation pipeline. I made figures using Microsfoft Excel, OriginPro, SPSS, Matlab, SigmaPlot, matplotlib in python, base R, ggplot2 in R and many others. However, my current preffered tool for making graphics is the ggplot2 package in R. However, looking on the spectrum over the last ten years and the constant switch from one software/tools to the other, I dont expect that I will continue using ggplot2 for the next ten years.  

One thing I have learned over the years is that automation should be the main skills for scientists. Automation serve time for data preparation, analysis and producing outputs. In this post I will take you through how to visualize vector field of surface current from drifter observation using the *ggplot2* package [@ggplot]. I will further highlight the drawbacks of the default geom of ggplot2 and why it sometimes fail to produce elegant oceanographic plot. Last I will show you how to use altenative geoms from **metR** package [@metr] to make overcome the challenges inherited in **ggplot2** package.


```{r}
require(metR)
require(tidyverse)
require(lubridate)
require(oce)
require(ocedata)
require(sf)
```



```{r echo=FALSE, warning=FALSE, message=FALSE}
world = spData::world

wio = world %>% st_crop(xmin =35 , ymin = -7, xmax = 46, ymax = 0)

africa = read_sf("E:/GIS/Tanzania spatial data Bank/EAF14 Tanzania spatial datasets/africa/Spatial/AdmInfr/afcntry.shp")

tz.ke = africa %>% st_crop(xmin =35 , ymin = -12, xmax = 46, ymax = 3)
```


##  Dataset
The drifter dataset contain surface current information linked to locations in the physical world. This spatial information help us to understand where the high speed current versus low speed current are found in the ocean. It is helpful to visualize this kind of data in the proper geospatial context i.e to show the data on a realistic map. I have filtered the data to cover the western part of the tropical indian ocean. I prepared and arrange drifter information in data frame---a rectangular collection of variables (columns) and observations (rows).  The dataset contains observation of surface current worlwide collected by the Global Drifter Program on all major oceans. Among the variables in the dataset are shown in table \@ref(tab:tab1) include:

+ id: a unique number of drifter
+ lon: longitude information
+ lat: latitude information
+ year, month, day, hour of the drifter records
+ u: the zonal component of surface current
+ v: the meridional component of the surface current
+ sst: the sea surface temperature information
+ season: whether the observation was collected during the northeast (NE) or southeast (SE) monsoon season

```{r echo=FALSE}
## load drifter data
drifter = read_table2("E:/Data Manipulation/drifter/tropind_drifters.txt", col_names = FALSE)

## insert variable names
drifter = drifter %>% select(id = X1, lon = X2, lat = X3, year= X8, month =   X9, 
                             day =  X10, hour = X11, drogue = X4, u =X5, v = X6,   sst = X7)
 
## create season
drifter = drifter %>% 
  mutate(season = month, 
         season = replace(season,season %in% c(11,12,1,2,3, 4), "NE"),
         # season = replace(season,season %in% c(4,10), "IN"),
         season = replace(season,season %in% c(5,6,7,8,9,10 ), "SE"))

## subset for the Area of interest
drifter.kimbiji = drifter %>% filter(lon >=38 & lon <= 45 & lat >=-8 & lat <= 0) 

```

```{r tab1, echo=FALSE}
drifter.kimbiji%>%select(-c(drogue, season)) %>% sample_n(12) %>% DT::datatable(caption = "A sample of drifter dataset", rownames = FALSE )
```

The drifter observations were randomly distributed within the area as shown in figure \@ref(fig:fig1) and requires binning---a process of making equal size grid in the area. 

```{r fig1, fig.cap="The distribution of drifter observation within the area"}

ggplot() +
  geom_point(data = drifter.kimbiji %>% sample_frac(.1) , aes(x = lon, y = lat))+
  geom_sf(data = tz.ke,fill = "lightgrey", col = "black")+
  coord_sf(ylim = c(-7,-1), xlim = c(38.5, 42))+
  labs(x = NULL, y = NULL)


```

To minimize biasness of sampling, the area was divided into equal size grids showin in figure \@ref(fig:fig2). 
```{r fig2, fig.cap="Gridded area to fill drifter observations"}

## convert drifter observation into simple features
drifter.kimbiji.sf = drifter.kimbiji %>% st_as_sf(coords = c("lon", "lat")) %>%
  st_set_crs(4326)

## divide the tropical indian ocean region into grids
drifter.grid = drifter.kimbiji.sf %>% st_make_grid(n = c(70,60))%>%st_sf()

## 
ggplot()+
  geom_sf(data = drifter.grid)+
  geom_sf(data = tz.ke,fill = "lightgrey", col = "black")+
  coord_sf(ylim = c(-7,-1), xlim = c(38.5, 42))

```



```{r echo=FALSE}

drifter.kimbiji.sf.ne = drifter.kimbiji.sf%>% filter(season =="NE")

drifter.gridded = drifter.grid %>% 
  mutate(id = 1:n(), contained = lapply(st_contains(st_sf(geometry),drifter.kimbiji.sf.ne),identity),
         obs = sapply(contained, length),
         u = sapply(contained, function(x) {median(drifter.kimbiji.sf.ne[x,]$u, na.rm = TRUE)}),
         v = sapply(contained, function(x) {median(drifter.kimbiji.sf.ne[x,]$v, na.rm = TRUE)})) 


drifter.gridded = drifter.gridded %>% select(obs, u, v) %>% na.omit()
coordinates = drifter.gridded %>% 
  st_centroid() %>% 
  st_coordinates() %>% 
  as_tibble() %>% rename(x = X, y = Y)

st_geometry(drifter.gridded) = NULL

current.gridded.ne = coordinates %>% 
  bind_cols(drifter.gridded)%>% 
  mutate(season = "NE")
```

Once the area was gridded,  then the the mean value of U and V component and the number of observation were calculated in each grid cell.

```{r}
drifter.kimbiji.sf.se = drifter.kimbiji.sf%>% filter(season=="SE")

drifter.gridded = drifter.grid %>% 
  mutate(id = 1:n(), contained = lapply(st_contains(st_sf(geometry),drifter.kimbiji.sf.se),identity),
         obs = sapply(contained, length),
         u = sapply(contained, function(x) {median(drifter.kimbiji.sf.se[x,]$u, na.rm = TRUE)}),
         v = sapply(contained, function(x) {median(drifter.kimbiji.sf.se[x,]$v, na.rm = TRUE)})) 

```

Then convert the gridded drifter information into data frame
```{r}

drifter.gridded = drifter.gridded %>% select(obs, u, v) %>% na.omit()

## obtain the centroid coordinates from the grid as table
coordinates = drifter.gridded %>% 
  st_centroid() %>% 
  st_coordinates() %>% 
  as_tibble() %>% 
  rename(x = X, y = Y)

## remove the geometry from the simple feature of gridded drifter dataset
st_geometry(drifter.gridded) = NULL

## stitch together the extracted coordinates and drifter information int a single table for SE monsoon season
current.gridded.se = coordinates %>% bind_cols(drifter.gridded) %>% mutate(season = "SE")

drifter.current.gridded = current.gridded.ne %>% bind_rows(current.gridded.se)

```

After binning, we found that some grids lack the drifter information, therefore, these grids were filled with the U, V values using the Interpolation technique.
```{r}
## select grids for SE season only
drf.se = drifter.current.gridded %>%filter(season == "SE")

## interpolate the U component
u.se = interpBarnes(x = drf.se$x, y = drf.se$y, z = drf.se$u)
dimension = data.frame(lon = u.se$xg, u.se$zg) %>% dim()

## make a U component data table from interpolated matrix
u.tb = data.frame(lon = u.se$xg, u.se$zg) %>% gather(key = "lata", value = "u", 2:dimension[2]) %>% mutate(lat = rep(u.se$yg, each = dimension[1])) %>% select(lon,lat, u) %>% as.tibble()

## interpolate the V component
v.se = interpBarnes(x = drf.se$x, y = drf.se$y, z = drf.se$v)

## make the V component data table from interpolated matrix
v.tb = data.frame(lon = v.se$xg, v.se$zg) %>% gather(key = "lata", value = "v", 2:dimension[2]) %>% mutate(lat = rep(v.se$yg, each = dimension[1])) %>% select(lon,lat, v) %>% as.tibble()

## interpolate the observations
ob.se = interpBarnes(x = drf.se$x, y = drf.se$y, z = drf.se$obs)

## make the V component data table from interpolated matrix
obs.tb = data.frame(lon = ob.se$xg, ob.se$zg) %>% gather(key = "lata", value = "obs", 2:dimension[2]) %>% mutate(lat = rep(ob.se$yg, each = dimension[1])) %>% select(lon,lat, obs) %>% as.tibble()

## stitch now the V component intot the U data table and compute the velocity
uv.se = u.tb %>% bind_cols(v.tb %>% select(v), obs.tb %>% select(obs)) %>% mutate(vel = sqrt(u^2+v^2))


```

### Visualising SE monsoon

```{r se-obs}
ggplot() +
  metR::geom_contour_fill(data = uv.se, aes(x = lon, y = lat, z = obs), na.fill = TRUE, bins = 40) + 
  geom_sf(data = tz.ke,fill = "lightgrey", col = "black")+
  coord_sf(ylim = c(-7,-1), xlim = c(38.5, 42))+
  scale_fill_gradientn(name = "Current",colours = oceColorsJet(120), 
                       limits = c(0,16),
                       breaks =seq(4,16,4),
                       na.value = "white")+
  labs(x = "", y = "")+
  theme(legend.position = "right", 
        legend.background = element_blank())
```


```{r se-vector}
ggplot() +
  metR::geom_contour_fill(data = uv.se, aes(x = lon, y = lat, z = vel), na.fill = TRUE, bins = 70) + 
  metR::geom_vector(data = uv.se, aes(x = lon, y = lat, dx = u, dy = v), 
                    arrow.angle = 20, arrow.type = "open", arrow.length = .5, 
                    pivot = 0,preserve.dir = TRUE, direction = "ccw")+
  geom_sf(data = tz.ke,fill = "lightgrey", col = "black")+
  coord_sf(ylim = c(-7,-1), xlim = c(38.5, 42))+
  scale_fill_gradientn(name = "Current",
                       colours = oceColorsVelocity(120), 
                       # limits = c(0,1.6), 
                       # breaks =seq(0.2,1.6,.3), 
                       na.value = "white")+
  labs(x = "", y = "")+
  theme(legend.position = "right", 
        legend.background = element_blank())+
  scale_mag(max = 1.8, name = expression(speed~(ms^{-1})))

```


```{r se-massless}
ggplot()+
metR::geom_streamline(data = uv.se, 
                        aes(x = lon, y = lat, dx = u, dy = v, 
                            color = sqrt(..dx..^2 + ..dy..^2), 
                            alpha = ..step..),
                      L = 2, res = 2, n = 60, 
                      arrow = NULL, lineend = "round")+
  geom_sf(data = tz.ke,fill = "lightgrey", col = "black")+
  coord_sf(ylim = c(-7,-1), xlim = c(38.5, 42))+
  scale_color_viridis_c(guide = "none")+
  scale_size(range = c(0.2, 1.5), guide = "none") +
  scale_alpha(guide = "none") +
  theme_bw()+
  theme(legend.position = "right",
        legend.key.height = unit(1.4, "cm"), 
        legend.background = element_blank(),
        axis.text = element_text(size = 12, colour = 1))+  
  labs(x = "", y = "")
```


### Visualising NE monsoon

```{r}
## nelect grids for ne neason only
drf.ne = drifter.current.gridded %>%filter(season == "NE")

## interpolate the U component
u.ne = interpBarnes(x = drf.ne$x, y = drf.ne$y, z = drf.ne$u)
dimension = data.frame(lon = u.ne$xg, u.ne$zg) %>% dim()

## make a U component data table from interpolated matrix
u.tb = data.frame(lon = u.ne$xg, u.ne$zg) %>% gather(key = "lata", value = "u", 2:dimension[2]) %>% mutate(lat = rep(u.ne$yg, each = dimension[1])) %>% select(lon,lat, u) %>% as.tibble()

## interpolate the V component
v.ne = interpBarnes(x = drf.ne$x, y = drf.ne$y, z = drf.ne$v)

## make the V component data table from interpolated matrix
v.tb = data.frame(lon = v.ne$xg, v.ne$zg) %>% gather(key = "lata", value = "v", 2:dimension[2]) %>% mutate(lat = rep(v.ne$yg, each = dimension[1])) %>% select(lon,lat, v) %>% as.tibble()

## interpolate the obnervations
ob.ne = interpBarnes(x = drf.ne$x, y = drf.ne$y, z = drf.ne$obs)

## make the V component data table from interpolated matrix
obs.tb = data.frame(lon = ob.ne$xg, ob.ne$zg) %>% gather(key = "lata", value = "obs", 2:dimension[2]) %>% mutate(lat = rep(ob.ne$yg, each = dimension[1])) %>% select(lon,lat, obs) %>% as.tibble()

## stitch now the V component intot the U data table and compute the velocity
uv.ne = u.tb %>% bind_cols(v.tb %>% select(v), obs.tb %>% select(obs)) %>% mutate(vel = sqrt(u^2+v^2))


```




```{r ne-obs}
ggplot() +
  metR::geom_contour_fill(data = uv.ne, aes(x = lon, y = lat, z = obs), na.fill = TRUE, bins = 40) + 
  geom_sf(data = tz.ke,fill = "lightgrey", col = "black")+
  coord_sf(ylim = c(-7,-1), xlim = c(38.5, 42))+
  scale_fill_gradientn(name = "Current",colours = oceColorsJet(120), 
                       limits = c(0,23),
                       breaks =seq(4,20,4),
                       na.value = "white")+
  labs(x = "", y = "")+
  theme(legend.position = "right", 
        legend.background = element_blank())
```


```{r ne-vector}
ggplot() +
  metR::geom_contour_fill(data = uv.ne, aes(x = lon, y = lat, z = vel), na.fill = TRUE, bins = 70) + 
  metR::geom_vector(data = uv.ne, aes(x = lon, y = lat, dx = u, dy = v), 
                    arrow.angle = 20, arrow.type = "open", arrow.length = .5, 
                    pivot = 0,preserve.dir = TRUE, direction = "ccw")+
  geom_sf(data = tz.ke,fill = "lightgrey", col = "black")+
  coord_sf(ylim = c(-7,-1), xlim = c(38.5, 42))+
  scale_fill_gradientn(name = "Current",
                       colours = oceColorsVelocity(120), 
                       limits = c(0,1.6),
                       breaks =seq(0.2,1.6,.3),
                       na.value = "white")+
  labs(x = "", y = "")+
  theme(legend.position = "right", 
        legend.background = element_blank())+
  scale_mag(max = 1.6, name = expression(speed~(ms^{-1})))

```


```{r ne-massless}

ggplot()+
metR::geom_streamline(data = uv.ne, 
                        aes(x = lon, y = lat, dx = u, dy = v, 
                            color = sqrt(..dx..^2 + ..dy..^2), 
                            alpha = ..step..),
                      L = 2, res = 2, n = 60, 
                      arrow = NULL, lineend = "round")+
  geom_sf(data = tz.ke,fill = "lightgrey", col = "black")+
  coord_sf(ylim = c(-7,-1), xlim = c(38.5, 42))+
  scale_color_viridis_c(guide = "none")+
  scale_size(range = c(0.2, 1.5), guide = "none") +
  scale_alpha(guide = "none") +
  theme_bw()+
  theme(legend.position = "right",
        legend.key.height = unit(1.4, "cm"), 
        legend.background = element_blank(),
        axis.text = element_text(size = 12, colour = 1))+  
  labs(x = "", y = "")
```